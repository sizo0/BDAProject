options {

    
       STATIC = false;                                                                                                                                        
     FORCE_LA_CHECK=false;                                                           
  
}


    PARSER_BEGIN(XPath)

package parser.sql;

import org.w3c.xqparser.Node;
import org.w3c.xqparser.SimpleNode;

import java.io.*;
import java.util.Stack;
import java.util.Vector;
import org.w3c.dom.Element;
import org.w3c.dom.Document;
import javax.xml.parsers.*;
import org.w3c.dom.traversal.DocumentTraversal;
import org.w3c.dom.traversal.NodeFilter;
import org.w3c.dom.traversal.NodeIterator;
import org.w3c.dom.traversal.TreeWalker;

import query.*;

public class XPath implements XPathTreeConstants {

      Query query;
      boolean isStep = false;

    Stack _elementStack = new Stack();

      Stack binaryTokenStack = new Stack();



    void checkCharRef(String ref) throws ParseException
    {
            ref = ref.substring(2, ref.length() - 1);
            int val;
            if (ref.charAt(0) == 'x') {
                val = Integer.parseInt(ref.substring(1), 16);
            } else
                val = Integer.parseInt(ref);
            boolean isLegal = val == 0x9 || val == 0xA || val == 0xD
                    || (val >= 0x20 && val <= 0xD7FF)
                    || (val >= 0xE000 && val <= 0xFFFD)
                    || (val >= 0x10000 && val <= 0x10FFFF);
            if (!isLegal)
                throw new ParseException(
                        "Well-formedness constraint: Legal Character, \n"
                                + "Characters referred to using character references MUST match the production for Char.");
        }
    


      public static void main(String args[])
         throws Exception
{
                java.io.DataInputStream dinput = new java.io.DataInputStream(System.in);
                while(true) {
    try
        {
            System.err.println("Type Expression: ");
            String input =  dinput.readLine();
            if(null == input || input.trim().length() == 0)
              break;
            XPath parser = new XPath(new BufferedReader(new InputStreamReader(new java.io.StringBufferInputStream(input), "UTF-8")));
          parser.XPath2();
        }
        catch(ParseException pe)
        {
          System.err.println(pe.getMessage());
        }
        catch(Exception e)
        {
          System.err.println(e.getMessage());
        }
        catch(Error e)
        {
          String msg = e.getMessage();
          if(msg == null || msg.equals(""))
            msg = "Unknown Error: "+e.getClass().getName();
          System.err.println(msg);
        }
}
}
}

    PARSER_END(XPath)

  

TOKEN_MGR_DECLS : {
  public Stack stateStack = new Stack();
  // private Vector persistentLexStates  = new Vector();
  static final int PARENMARKER = 2000;
  public int offset = 0;
  
  
  void CommonTokenAction(Token t) {}  

  
  /**
   * Push the current state onto the state stack.
   */
  private void pushState()
  {
    
    stateStack.addElement(new Integer(curLexState));
  }
  
  /**
   * Push the given state onto the state stack.
   * @param state Must be a valid state.
   */
  private void pushState(int state)
  {
  
    stateStack.push(new Integer(state));
  }
  
  /**
   * Pop the state on the state stack, and switch to that state.
   */
  private void popState()
  {
    if (stateStack.size() == 0)
    {
      printLinePos();
    }

    int nextState = ((Integer) stateStack.pop()).intValue();
    
    if(nextState == PARENMARKER)
      printLinePos();
    SwitchTo(nextState);
  }
  
  /**
   * Push the given state onto the state stack.
   * @param state Must be a valid state.
   */
  private boolean isState(int state)
  {
  for (int i = 0; i < stateStack.size(); i++) {
        if(((Integer) stateStack.elementAt(i)).intValue() == state)
        {
          return true;
        }
  }
  return false;
  }

  /**
   * Push a parenthesis state.  This pushes, in addition to the 
   * lexical state value, a special marker that lets 
   * resetParenStateOrSwitch(int state)
   * know if it should pop and switch.  Used for the comma operator.
   */
  private void pushParenState(int commaState, int rparState)
  {
    stateStack.push(new Integer(rparState));
    stateStack.push(new Integer(commaState));
    stateStack.push(new Integer(PARENMARKER));
    SwitchTo(commaState);
  }


  /**
   * Print the current line position.
   */
  public void printLinePos()
  {
    System.err.println("Line: " + input_stream.getEndLine());
  }
}


    void XPath2() :
    {}
    {
      QueryList()<EOF>
      { if(this.token_source.curLexState == XPathConstants.EXPR_COMMENT)
                            throw new ParseException("Unterminated comment.");
      }
    }
      void QueryList()  :
{System.out.println("QueryList");}
{
  Module() ("%%%" [Module()])*
}

void Module()  :
{System.out.println("Module");}
{
  [LOOKAHEAD(2) VersionDecl()] (LOOKAHEAD(2) LibraryModule() | MainModule())
}

void VersionDecl()  :
{System.out.println("VersionDecl");}
{
  "xquery" "version" <StringLiteral> ["encoding" <StringLiteral>] Separator()
}

void MainModule()  :
{System.out.println("MainModule");}
{
  Prolog() QueryBody()
}

void LibraryModule()  :
{System.out.println("LibraryModule");}
{
  ModuleDecl() Prolog()
}

void ModuleDecl()  :
{System.out.println("ModuleDecl");}
{
  "module" "namespace" NCName() "=" URILiteral() Separator()
}

void Prolog()  :
{System.out.println("Prolog");}
{
  (LOOKAHEAD(2) (LOOKAHEAD(3) DefaultNamespaceDecl() | LOOKAHEAD(3) Setter() | LOOKAHEAD(2) NamespaceDecl() | Import()) Separator())* (LOOKAHEAD(2) (LOOKAHEAD(2) VarDecl() | LOOKAHEAD(2) FunctionDecl() | LOOKAHEAD(2) OptionDecl()) Separator())*
}

void Setter()  :
{System.out.println("Setter");}
{
  (LOOKAHEAD(2) BoundarySpaceDecl() | LOOKAHEAD(3) DefaultCollationDecl() | LOOKAHEAD(2) BaseURIDecl() | LOOKAHEAD(2) ConstructionDecl() | LOOKAHEAD(2) OrderingModeDecl() | LOOKAHEAD(3) EmptyOrderDecl() | CopyNamespacesDecl())
}

void Import()  :
{System.out.println("Import");}
{
  (LOOKAHEAD(2) SchemaImport() | ModuleImport())
}

void Separator()  :
{System.out.println("Separator");}
{
  ";"
}

void NamespaceDecl()  :
{System.out.println("NamespaceDecl");}
{
  "declare" "namespace" NCName() "=" URILiteral()
}

void BoundarySpaceDecl()  :
{System.out.println("BoundarySpaceDecl");}
{
  "declare" "boundary-space" ("preserve"{} | "strip"{})
}

void DefaultNamespaceDecl()  :
{System.out.println("DefaultNamespaceDecl");}
{
  "declare" "default" ("element"{} | "function"{}) "namespace" URILiteral()
}

void OptionDecl()  :
{System.out.println("OptionDecl");}
{
  "declare" "option" QName() <StringLiteral>
}

void OrderingModeDecl()  :
{System.out.println("OrderingModeDecl");}
{
  "declare" "ordering" ("ordered"{} | "unordered"{})
}

void EmptyOrderDecl()  :
{System.out.println("EmptyOrderDecl");}
{
  "declare" "default" "order" "empty" (<Greatest> | <Least>)
}

void CopyNamespacesDecl()  :
{System.out.println("CopyNamespacesDecl");}
{
  "declare" "copy-namespaces" PreserveMode() "," InheritMode()
}

void PreserveMode()  :
{System.out.println("PreserveMode");}
{
  ("preserve"{} | "no-preserve"{})
}

void InheritMode()  :
{System.out.println("InheritMode");}
{
  ("inherit"{} | "no-inherit"{})
}

void DefaultCollationDecl()  :
{System.out.println("DefaultCollationDecl");}
{
  "declare" "default" "collation" URILiteral()
}

void BaseURIDecl()  :
{System.out.println("BaseURIDecl");}
{
  "declare" "base-uri" URILiteral()
}

void SchemaImport()  :
{System.out.println("SchemaImport");}
{
  "import" "schema" [SchemaPrefix()] URILiteral() ["at" URILiteral() ("," URILiteral())*]
}

void SchemaPrefix()  :
{System.out.println("SchemaPrefix");}
{
  ( (
"namespace" NCName() "=") |  (
"default" "element" "namespace"))
}

void ModuleImport()  :
{System.out.println("ModuleImport");}
{
  "import" "module" ["namespace" NCName() "="] URILiteral() ["at" URILiteral() ("," URILiteral())*]
}

void VarDecl()  :
{System.out.println("VarDecl");}
{
  "declare" "variable" "$" QName() [TypeDeclaration()] ( (
":=" ExprSingle()) | <External>)
}

void ConstructionDecl()  :
{System.out.println("ConstructionDecl");}
{
  "declare" "construction" ("strip"{} | "preserve"{})
}

void FunctionDecl()  :
{System.out.println("FunctionDecl");}
{
  "declare" "function" QName() "(" [ParamList()] ")" ["as" SequenceType()] (EnclosedExpr() | <External>)
}

void ParamList()  :
{System.out.println("ParamList");}
{
  Param() ("," Param())*
}

void Param()  :
{System.out.println("Param");}
{
  "$" QName() [TypeDeclaration()]
}

void EnclosedExpr()  :
{System.out.println("EnclosedExpr");}
{
  (<Lbrace> | <LbraceExprEnclosure>) Expr() <Rbrace>
}

void QueryBody()  :
{System.out.println("QueryBody");}
{
  Expr()
}

void Expr()  :
{System.out.println("Expr");}
{
  ExprSingle() ("," ExprSingle())*
}

void ExprSingle()        :
{System.out.println("ExprSingle");}
{
  (LOOKAHEAD(2) FLWORExpr() | LOOKAHEAD(2) QuantifiedExpr() | LOOKAHEAD(2) TypeswitchExpr() | LOOKAHEAD(2) IfExpr() | OrExpr())
}

void FLWORExpr()  :
{System.out.println("FLWORExpr");}
{
  ((ForClause() | LetClause()))+  [WhereClause()] [OrderByClause()] "return" ExprSingle()
}

void ForClause()  :
{System.out.println("ForClause");}
{
  {query = new Select();}
  "for" "$" VarName() [TypeDeclaration()] [PositionalVar()] "in" ExprSingle() ("," "$" VarName() [TypeDeclaration()] [PositionalVar()] "in" ExprSingle())*
}

void PositionalVar()  :
{System.out.println("PositionalVar");}
{
  "at" "$" VarName()
}

void LetClause()  :
{System.out.println("LetClause");}
{
   (
"let" "$" VarName() [TypeDeclaration()]) ":=" ExprSingle() (","  (
"$" VarName() [TypeDeclaration()]) ":=" ExprSingle())*
}

void WhereClause()  :
{System.out.println("WhereClause");}
{
  "where" ExprSingle()
}

void OrderByClause()  :
{System.out.println("OrderByClause");}
{
  ( (
"order" "by") |  (
"stable"{} "order" "by")) OrderSpecList()
}

void OrderSpecList()  :
{System.out.println("OrderSpecList");}
{
  OrderSpec() ("," OrderSpec())*
}

void OrderSpec()  :
{System.out.println("OrderSpec");}
{
  ExprSingle() OrderModifier()
}

void OrderModifier()  :
{System.out.println("OrderModifier");}
{
  [(<Ascending> | <Descending>)] ["empty" (<Greatest> | <Least>)] ["collation" URILiteral()]
}

void QuantifiedExpr()  :
{System.out.println("QuantifiedExpr");}
{
  ("some"{} | "every"{}) "$" VarName() [TypeDeclaration()] "in" ExprSingle() ("," "$" VarName() [TypeDeclaration()] "in" ExprSingle())* "satisfies" ExprSingle()
}

void TypeswitchExpr()  :
{System.out.println("TypeswitchExpr");}
{
  "typeswitch" "(" Expr() ")" (CaseClause())+  "default" ["$" VarName()] "return" ExprSingle()
}

void CaseClause()  :
{System.out.println("CaseClause");}
{
  "case" ["$" VarName() "as"] SequenceType() "return" ExprSingle()
}

void IfExpr()  :
{System.out.println("IfExpr");}
{
  "if" "(" Expr() ")" "then" ExprSingle() "else" ExprSingle()
}

void OperatorExpr()         : 
{System.out.println("OperatorExpr");}
{
  OrExpr()
}

void OrExpr()              : 
{System.out.println("OrExpr");}
{
  AndExpr() ("or"{
        binaryTokenStack.push(token);
      } AndExpr()
    {
         try
         {
         
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
    })*
}

void AndExpr()               : 
{System.out.println("AndExpr");}
{
  ComparisonExpr() ("and"{
        binaryTokenStack.push(token);
      } ComparisonExpr()
    {
         try
         {
         
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
    })*
}

void ComparisonExpr()                      : 
{System.out.println("ComparisonExpr");}
{
  RangeExpr() ((ValueComp() | GeneralComp() | NodeComp()) RangeExpr()
    {
         try
         {
         
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
    })?
}

void RangeExpr()                 : 
{System.out.println("RangeExpr");}
{
  AdditiveExpr() ("to"{
        binaryTokenStack.push(token);
      } AdditiveExpr()
    {
         try
         {
         
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
    })?
}

void AdditiveExpr()                    : 
{System.out.println("AdditiveExpr");}
{
  MultiplicativeExpr() ((<Plus>
            
         {binaryTokenStack.push(token);}
       | <Minus>
            
         {binaryTokenStack.push(token);}
      ) MultiplicativeExpr()
    {
         try
         {
         
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
    })*
}

void MultiplicativeExpr()                          : 
{System.out.println("MultiplicativeExpr");}
{
  UnionExpr() (("*"{
        binaryTokenStack.push(token);
      } | "div"{
        binaryTokenStack.push(token);
      } | "idiv"{
        binaryTokenStack.push(token);
      } | "mod"{
        binaryTokenStack.push(token);
      }) UnionExpr()
    {
         try
         {
         
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
    })*
}

void UnionExpr()                 : 
{System.out.println("UnionExpr");}
{
  IntersectExceptExpr() (("union"{
        binaryTokenStack.push(token);
      } | "|"{
        binaryTokenStack.push(token);
      }) IntersectExceptExpr()
    {
         try
         {
         
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
    })*
}

void IntersectExceptExpr()                           : 
{System.out.println("IntersectExceptExpr");}
{
  InstanceofExpr() (("intersect"{
        binaryTokenStack.push(token);
      } | "except"{
        binaryTokenStack.push(token);
      }) InstanceofExpr()
    {
         try
         {
         
         }
         catch(java.util.EmptyStackException e)
         {
           token_source.printLinePos();
           e.printStackTrace();
           throw e;
         }
    })*
}

void InstanceofExpr()                      : 
{System.out.println("InstanceofExpr");}
{
  TreatExpr()  (
"instance" "of" SequenceType())?
}

void TreatExpr()                 : 
{System.out.println("TreatExpr");}
{
  CastableExpr()  (
"treat" "as" SequenceType())?
}

void CastableExpr()                    : 
{System.out.println("CastableExpr");}
{
  CastExpr()  (
"castable" "as" SingleType())?
}

void CastExpr()                : 
{System.out.println("CastExpr");}
{
  UnaryExpr()  (
"cast" "as" SingleType())?
}

void UnaryExpr()                       : 
{System.out.println("UnaryExpr");boolean keepUnary=false;}
{
  (<Minus>{keepUnary=true;} | <Plus>{keepUnary=true;})* ValueExpr()
}

void ValueExpr()       : 
{System.out.println("ValueExpr");}
{
  (LOOKAHEAD(2) ValidateExpr() | PathExpr() | ExtensionExpr())
}

void GeneralComp()        :
{System.out.println("GeneralComp");}
{
  ("="{
        binaryTokenStack.push(token);
      } | "!="{
        binaryTokenStack.push(token);
      } | <LessThanOpOrTagO>
          {/* Careful! */ token_source.SwitchTo(DEFAULT); token_source.stateStack.pop(); }
        
            
         {binaryTokenStack.push(token);}
       | "<="{
        binaryTokenStack.push(token);
      } | ">"{
        binaryTokenStack.push(token);
      } | ">="{
        binaryTokenStack.push(token);
      })
}

void ValueComp()        :
{System.out.println("ValueComp");}
{
  ("eq"{
        binaryTokenStack.push(token);
      } | "ne"{
        binaryTokenStack.push(token);
      } | "lt"{
        binaryTokenStack.push(token);
      } | "le"{
        binaryTokenStack.push(token);
      } | "gt"{
        binaryTokenStack.push(token);
      } | "ge"{
        binaryTokenStack.push(token);
      })
}

void NodeComp()        :
{System.out.println("NodeComp");}
{
  ("is"{
        binaryTokenStack.push(token);
      } | "<<"{
        binaryTokenStack.push(token);
      } | ">>"{
        binaryTokenStack.push(token);
      })
}

void ValidateExpr()  :
{System.out.println("ValidateExpr");}
{
  "validate" [ValidationMode()] <LbraceExprEnclosure> Expr() <Rbrace>
}

void ValidationMode()  :
{System.out.println("ValidationMode");}
{
  ("lax"{} | "strict"{})
}

void ExtensionExpr()  :
{System.out.println("ExtensionExpr");}
{
  (Pragma())+  <LbraceExprEnclosure> [Expr()] <Rbrace>
}

void Pragma()  :
{System.out.println("Pragma");}
{
  <PragmaOpen> [<S>] <QNameForPragma> [<SForPragma> PragmaContents()] <PragmaClose>{}
}

void PragmaContents()  :
{System.out.println("PragmaContents");}
{
  (<ExtensionContentChar>)*
}

void PathExpr()                :
{System.out.println("PathExpr");}
{
  ( (
<Slash> [LOOKAHEAD(1) RelativePathExpr()]) |  (
<SlashSlash> RelativePathExpr()) | RelativePathExpr())
}

void RelativePathExpr()        :
{System.out.println("RelativePathExpr");}
{
  StepExpr() ((<Slash> | <SlashSlash>) StepExpr())*
}

void StepExpr()                          :
{System.out.println("StepExpr");boolean savedIsStep = isStep; isStep=false;}
{
  (LOOKAHEAD(3) FilterExpr(){isStep = savedIsStep;} | {isStep=true;}AxisStep(){isStep = savedIsStep;})
}

void AxisStep()        :
{System.out.println("AxisStep");}
{
  (LOOKAHEAD(2) ReverseStep() | ForwardStep()) PredicateList()
}

void ForwardStep()        :
{System.out.println("ForwardStep");}
{
  (LOOKAHEAD(2)  (
ForwardAxis() NodeTest()) | AbbrevForwardStep())
}

void ForwardAxis()  :
{System.out.println("ForwardAxis");}
{
  ( (
"child"{} "::") |  (
"descendant" "::") |  (
"attribute" "::") |  (
"self"{} "::") |  (
"descendant-or-self"{} "::") |  (
"following-sibling"{} "::") |  (
"following"{} "::"))
}

void AbbrevForwardStep()  :
{System.out.println("AbbrevForwardStep");}
{
  ["@"{}] NodeTest()
}

void ReverseStep()        :
{System.out.println("ReverseStep");}
{
  ( (
ReverseAxis() NodeTest()) | AbbrevReverseStep())
}

void ReverseAxis()  :
{System.out.println("ReverseAxis");}
{
  ( (
"parent"{} "::") |  (
"ancestor"{} "::") |  (
"preceding-sibling"{} "::") |  (
"preceding"{} "::") |  (
"ancestor-or-self"{} "::"))
}

void AbbrevReverseStep()  :
{System.out.println("AbbrevReverseStep");}
{
  ".."
}

void NodeTest()  :
{System.out.println("NodeTest");}
{
  (LOOKAHEAD(2) KindTest() | NameTest())
}

void NameTest()  :
{System.out.println("NameTest");}
{
  (QName() | Wildcard())
}

void Wildcard()  :
{System.out.println("Wildcard");}
{
  ("*" | <NCNameColonStar> | <StarColonNCName>)
}

void FilterExpr()        :
{System.out.println("FilterExpr");}
{
  PrimaryExpr() PredicateList()
}

void PredicateList()                      :
{System.out.println("PredicateList");}
{
  (Predicate())*
}

void Predicate()                  :
{System.out.println("Predicate");}
{
  "[" Expr() "]"
}

void PrimaryExpr()        :
{System.out.println("PrimaryExpr");}
{
  (Literal() | VarRef() | ParenthesizedExpr() | {isStep=true;}ContextItemExpr() | LOOKAHEAD(2) FunctionCall() | LOOKAHEAD(2) OrderedExpr() | LOOKAHEAD(2) UnorderedExpr() | Constructor())
}

void Literal()        :
{System.out.println("Literal");}
{
  (NumericLiteral() | <StringLiteral>)
}

void NumericLiteral()        :
{System.out.println("NumericLiteral");}
{
  (<IntegerLiteral> | <DecimalLiteral> | <DoubleLiteral>)
}

void VarRef()        :
{System.out.println("VarRef");}
{
  "$" VarName()
}

void VarName()  :
{System.out.println("VarName");}
{
  QName()
}

void ParenthesizedExpr()  :
{System.out.println("ParenthesizedExpr");}
{
  "(" [Expr()] ")"
}

void ContextItemExpr()  :
{System.out.println("ContextItemExpr");}
{
  "."{}
}

void OrderedExpr()  :
{System.out.println("OrderedExpr");}
{
  "ordered" <LbraceExprEnclosure> Expr() <Rbrace>
}

void UnorderedExpr()  :
{System.out.println("UnorderedExpr");}
{
  "unordered" <LbraceExprEnclosure> Expr() <Rbrace>
}

void FunctionCall()  :
{System.out.println("FunctionCall");}
{
  FunctionQName() "(" [ExprSingle() ("," ExprSingle())*] ")"
}

void Constructor()  :
{System.out.println("Constructor");}
{
  (DirectConstructor() | ComputedConstructor())
}

void DirectConstructor()  :
{System.out.println("DirectConstructor");}
{
  (DirElemConstructor() | DirCommentConstructor() | DirPIConstructor())
}

void DirElemConstructor()  :
{System.out.println("DirElemConstructor");}
{
  (<LessThanOpOrTagO> | <StartTagOpen>) <TagQName>{_elementStack.push(token.image); } DirAttributeList() (<EmptyTagClose>{_elementStack.pop(); } |  (
<StartTagClose>{} (DirElemContent())* <EndTagOpen> <EndTagQName>{if(!token.image.equals(_elementStack.pop())) throw new ParseException("Error: In a direct element constructor, the name used in the end tag must exactly match the name used in the corresponding start tag, including its prefix or absence of a prefix. Line: " + token.beginLine); } [<S>] <EndTagClose>))
}

void DirAttributeList()  :
{System.out.println("DirAttributeList");}
{
  (<S> [<TagQName> [<S>] <ValueIndicator> [<S>{}] DirAttributeValue()])*
}

void DirAttributeValue()  :
{System.out.println("DirAttributeValue");}
{
  ( (
<OpenQuot> ((<EscapeQuot> | QuotAttrValueContent()))* <CloseQuot>) |  (
<OpenApos> ((<EscapeApos>{} | AposAttrValueContent()))* <CloseApos>{}))
}

void QuotAttrValueContent()  :
{System.out.println("QuotAttrValueContent");}
{
  (<QuotAttrContentChar> | CommonContent())
}

void AposAttrValueContent()  :
{System.out.println("AposAttrValueContent");}
{
  (<AposAttrContentChar> | CommonContent())
}

void DirElemContent()  :
{System.out.println("DirElemContent");}
{
  (DirectConstructor() | CDataSection() | CommonContent() | <ElementContentChar>)
}

void CommonContent()  :
{System.out.println("CommonContent");}
{
  (<PredefinedEntityRef> | <CharRef>{checkCharRef(token.image);} | <LCurlyBraceEscape> | <RCurlyBraceEscape> | EnclosedExpr())
}

void DirCommentConstructor()  :
{System.out.println("DirCommentConstructor");}
{
  (<XmlCommentStartForElementContent> | <XmlCommentStart>) DirCommentContents() <XmlCommentEnd>
}

void DirCommentContents()  :
{System.out.println("DirCommentContents");}
{
  ((<CommentContentChar> | <CommentContentCharDash>))*
}

void DirPIConstructor()  :
{System.out.println("DirPIConstructor");}
{
  (<ProcessingInstructionStartForElementContent> | <ProcessingInstructionStart>) <PITarget> [<SForPI> DirPIContents()] <ProcessingInstructionEnd>{}
}

void DirPIContents()  :
{System.out.println("DirPIContents");}
{
  (<PIContentChar>)*
}

void CDataSection()  :
{System.out.println("CDataSection");}
{
  (<CdataSectionStartForElementContent> | <CdataSectionStart>) CDataSectionContents() <CdataSectionEnd>
}

void CDataSectionContents()  :
{System.out.println("CDataSectionContents");}
{
  (<CDataSectionChar>)*
}

void ComputedConstructor()  :
{System.out.println("ComputedConstructor");}
{
  (CompDocConstructor() | CompElemConstructor() | CompAttrConstructor() | CompTextConstructor() | CompCommentConstructor() | CompPIConstructor())
}

void CompDocConstructor()  :
{System.out.println("CompDocConstructor");}
{
  "document" <LbraceExprEnclosure> Expr() <Rbrace>
}

void CompElemConstructor()  :
{System.out.println("CompElemConstructor");}
{
  "element" (QName() |  (
<LbraceExprEnclosure> Expr() <Rbrace>)) <LbraceExprEnclosure> [ContentExpr()] <Rbrace>
}

void ContentExpr()  :
{System.out.println("ContentExpr");}
{
  Expr()
}

void CompAttrConstructor()  :
{System.out.println("CompAttrConstructor");}
{
  "attribute" (QName() |  (
<LbraceExprEnclosure> Expr() <Rbrace>)) <LbraceExprEnclosure> [Expr()] <Rbrace>
}

void CompTextConstructor()  :
{System.out.println("CompTextConstructor");}
{
  "text" <LbraceExprEnclosure> Expr() <Rbrace>
}

void CompCommentConstructor()  :
{System.out.println("CompCommentConstructor");}
{
  "comment" <LbraceExprEnclosure> Expr() <Rbrace>
}

void CompPIConstructor()  :
{System.out.println("CompPIConstructor");}
{
  "processing-instruction" (NCName() |  (
<LbraceExprEnclosure> Expr() <Rbrace>)) <LbraceExprEnclosure> [Expr()] <Rbrace>
}

void SingleType()  :
{System.out.println("SingleType");}
{
  AtomicType() ["?"{}]
}

void TypeDeclaration()  :
{System.out.println("TypeDeclaration");}
{
  "as" SequenceType()
}

void SequenceType()  :
{System.out.println("SequenceType");}
{
  (LOOKAHEAD(2)  (
"empty-sequence"{} "(" ")") |  (
ItemType() [LOOKAHEAD(1) OccurrenceIndicator()]))
}

void OccurrenceIndicator()  :
{System.out.println("OccurrenceIndicator");}
{
  ("?"{} | "*" | <Plus>)
}

void ItemType()  :
{System.out.println("ItemType");}
{
  (LOOKAHEAD(2) KindTest() | LOOKAHEAD(2)  (
"item"{} "(" ")") | AtomicType())
}

void AtomicType()  :
{System.out.println("AtomicType");}
{
  QName()
}

void KindTest()        :
{System.out.println("KindTest");}
{
  (DocumentTest() | ElementTest() | AttributeTest() | SchemaElementTest() | SchemaAttributeTest() | PITest() | CommentTest() | TextTest() | AnyKindTest())
}

void AnyKindTest()  :
{System.out.println("AnyKindTest");}
{
  "node" "(" ")"
}

void DocumentTest()  :
{System.out.println("DocumentTest");}
{
  "document-node" "(" [(ElementTest() | SchemaElementTest())] ")"
}

void TextTest()  :
{System.out.println("TextTest");}
{
  "text" "(" ")"
}

void CommentTest()  :
{System.out.println("CommentTest");}
{
  "comment" "(" ")"
}

void PITest()  :
{System.out.println("PITest");}
{
  "processing-instruction" "(" [(NCName() | <StringLiteral>)] ")"
}

void AttributeTest()  :
{System.out.println("AttributeTest");}
{
  "attribute" "(" [ (
AttribNameOrWildcard() ["," TypeName()])] ")"
}

void AttribNameOrWildcard()  :
{System.out.println("AttribNameOrWildcard");}
{
  (AttributeName() | "*")
}

void SchemaAttributeTest()  :
{System.out.println("SchemaAttributeTest");}
{
  "schema-attribute" "(" AttributeDeclaration() ")"
}

void AttributeDeclaration()  :
{System.out.println("AttributeDeclaration");}
{
  AttributeName()
}

void ElementTest()  :
{System.out.println("ElementTest");}
{
  "element" "(" [ (
ElementNameOrWildcard() ["," TypeName() ["?"{}]])] ")"
}

void ElementNameOrWildcard()  :
{System.out.println("ElementNameOrWildcard");}
{
  (ElementName() | "*")
}

void SchemaElementTest()  :
{System.out.println("SchemaElementTest");}
{
  "schema-element" "(" ElementDeclaration() ")"
}

void ElementDeclaration()  :
{System.out.println("ElementDeclaration");}
{
  ElementName()
}

void AttributeName()  :
{System.out.println("AttributeName");}
{
  QName()
}

void ElementName()  :
{System.out.println("ElementName");}
{
  QName()
}

void TypeName()  :
{System.out.println("TypeName");}
{
  QName()
}

void URILiteral()  :
{System.out.println("URILiteral");}
{
  <StringLiteral>
}

void NCName()  :
{System.out.println("NCName");}
{
  QName()
}

void QName()  :
{System.out.println("QName");}
{
  (FunctionQName() | "attribute" | "comment"{} | "document-node"{} | "element"{} | "if"{} | "item"{} | "node"{} | "processing-instruction"{} | "schema-attribute"{} | "schema-element"{} | "text"{} | "typeswitch"{} | "empty-sequence"{})
}

void FunctionQName()  :
{System.out.println("FunctionQName");}
{
  (<QNameToken> | <External> | "xquery"{} | "version"{} | "encoding"{} | "module"{} | "namespace"{} | "declare"{} | "boundary-space"{} | "preserve"{} | "strip"{} | "default"{} | "function"{} | "option"{} | "ordering"{} | "ordered"{} | "unordered"{} | "order"{} | "empty"{} | <Greatest> | <Least> | "copy-namespaces"{} | "no-preserve"{} | "inherit"{} | "no-inherit"{} | "collation"{} | "base-uri"{} | "import"{} | "schema"{} | "at"{} | "variable"{} | "construction"{} | "as"{} | "lax"{} | "strict"{} | "return"{} | "for"{} | "in"{} | "let"{} | "where"{} | "by"{} | "stable"{} | <Ascending> | <Descending> | "some"{} | "every"{} | "satisfies"{} | "case"{} | "then"{} | "else"{} | "or"{} | "and"{} | "to"{} | "div"{} | "idiv"{} | "mod"{} | "union"{} | "intersect"{} | "except"{} | "instance"{} | "of"{} | "treat"{} | "castable"{} | "cast"{} | "eq"{} | "ne"{} | "lt"{} | "le"{} | "gt"{} | "ge"{} | "is"{} | "validate" | "child"{} | "descendant" | "self"{} | "descendant-or-self"{} | "following-sibling"{} | "following"{} | "parent"{} | "ancestor"{} | "preceding-sibling"{} | "preceding"{} | "ancestor-or-self"{} | "document"{} | "type"{})
}


<DEFAULT>
TOKEN :
{
 < IntegerLiteral : <Digits> >
}

<DEFAULT>
TOKEN :
{
 < DecimalLiteral : ( (
"." <Digits>) |  (
<Digits> "." (["0" - "9"])*)) >
}

<DEFAULT>
TOKEN :
{
 < DoubleLiteral : ( (
"." <Digits>) |  (
<Digits> ("." (["0" - "9"])*)?)) ["e", "E"] (["+", "-"])? <Digits> >
}

<DEFAULT>
TOKEN :
{
 < StringLiteral : ( (
"\"" ((<PredefinedEntityRef> | <CharRef> | <EscapeQuot> | ~["\"", "&"]))* "\"") |  (
"'" ((<PredefinedEntityRef> | <CharRef> | <EscapeApos> | ~["'", "&"]))* "'")) >
}
<FTPOSFILTER, FTMATCHOPTION, PROLOG_SPECIAL, PROLOG_NCNAME, DECLAREORDERING, DEFAULT, PROLOG, OPERAND, OPERATOR, KINDTEST, NAMESPACEDECL, SINGLETYPE, ITEMTYPE, NAMESPACEKEYWORD, VARNAME, OCCURRENCEINDICATOR, CLOSEKINDTEST, XQUERYVERSION, PRAGMA, OPTION, URITOOPERATOR>
SKIP:
{
  <DUMMYLABEL:<skip_>>
}

TOKEN :
{
  < #skip_ :  (
(<WhitespaceChar>)+ ) >
}


<DEFAULT>
TOKEN :
{
 < Minus : "-" >
}

<DEFAULT>
TOKEN :
{
 < Plus : "+" >
}

<DEFAULT>
TOKEN :
{
 < External : "external" >
}

<DEFAULT>
TOKEN :
{
 < Ascending : "ascending" >
}

<DEFAULT>
TOKEN :
{
 < Descending : "descending" >
}

<DEFAULT>
TOKEN :
{
 < Greatest : "greatest" >
}

<DEFAULT>
TOKEN :
{
 < Least : "least" >
}

TOKEN :
{
 < #Prefix : <NCNameTok> >
}

TOKEN :
{
 < #LocalPart : <NCNameTok> >
}

TOKEN :
{
 < #Nmstart : (<Letter> | "_") >
}

TOKEN :
{
 < #Nmchar : (<Letter> | <CombiningChar> | <Extender> | <Digit> | "." | "-" | "_") >
}

<DEFAULT, ELEMENT_CONTENT, QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < PredefinedEntityRef : "&" ("lt" | "gt" | "amp" | "quot" | "apos") ";" >
}

<QUOT_ATTRIBUTE_CONTENT>
TOKEN :
{
 < EscapeQuot : "\"\"" > : QUOT_ATTRIBUTE_CONTENT
}

<APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < EscapeApos : "''" > : APOS_ATTRIBUTE_CONTENT
}

TOKEN :
{
 < #HexDigits : (["0" - "9", "a" - "f", "A" - "F"])+  >
}

<ELEMENT_CONTENT, QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < Lbrace : "{" > { pushState(); } : DEFAULT
}

<DEFAULT>
TOKEN :
{
 < LbraceExprEnclosure : "{" > { pushState(DEFAULT); } : DEFAULT
}

<DEFAULT>
TOKEN :
{
 < Rbrace : "}" > { popState(); }
}

<ELEMENT_CONTENT, QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < RbraceErrorInContent : "}" > { pushState(); } : DEFAULT
}

<ELEMENT_CONTENT, QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < LCurlyBraceEscape : "{{" >
}

<ELEMENT_CONTENT, QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < RCurlyBraceEscape : "}}" >
}

<ELEMENT_CONTENT, QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < Amp : "&" >
}

<DEFAULT>
TOKEN :
{
 < LessThanOpOrTagO : "<" > { pushState(DEFAULT); } : START_TAG
}

<ELEMENT_CONTENT>
TOKEN :
{
 < StartTagOpen : "<" > { pushState(); } : START_TAG
}

<QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < AttrLTCharError : "<" > { pushState(); } : DEFAULT
}

<START_TAG>
TOKEN :
{
 < StartTagClose : ">" > : ELEMENT_CONTENT
}

<START_TAG>
TOKEN :
{
 < OpenQuot : "\"" > : QUOT_ATTRIBUTE_CONTENT
}

<QUOT_ATTRIBUTE_CONTENT>
TOKEN :
{
 < CloseQuot : "\"" > : START_TAG
}

<START_TAG>
TOKEN :
{
 < OpenApos : "'" > : APOS_ATTRIBUTE_CONTENT
}

<APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < CloseApos : "'" > : START_TAG
}

<PRAGMACONTENTS>
TOKEN :
{
 < ExtensionContentChar : <Char> >
}

<ELEMENT_CONTENT>
TOKEN :
{
 < ElementContentChar : <Char> > : ELEMENT_CONTENT
}

<QUOT_ATTRIBUTE_CONTENT>
TOKEN :
{
 < QuotAttrContentChar : <Char> > : QUOT_ATTRIBUTE_CONTENT
}

<APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < AposAttrContentChar : <Char> > : APOS_ATTRIBUTE_CONTENT
}

<XML_COMMENT>
TOKEN :
{
 < CommentContentChar : <Char> > : XML_COMMENT
}

<START_TAG>
TOKEN :
{
 < EmptyTagClose : "/>" > { popState(); }
}

<ELEMENT_CONTENT>
TOKEN :
{
 < EndTagOpen : "</" > : END_TAG
}

<END_TAG>
TOKEN :
{
 < EndTagClose : ">" > { popState(); }
}

<START_TAG>
TOKEN :
{
 < ValueIndicator : "=" > : START_TAG
}

<DEFAULT>
TOKEN :
{
 < PragmaOpen : "(#" > : PRAGMA
}

<PRAGMACONTENTS, PRAGMACONTENTSSPACEDIVIDER>
TOKEN :
{
 < PragmaClose : "#)" > : DEFAULT
}

<XML_COMMENT>
TOKEN :
{
 < XMLCommentDoubleDashError : "-" "-" > : XML_COMMENT
}

<XML_COMMENT>
TOKEN :
{
 < CommentContentCharDash : "-" <Char> > : XML_COMMENT
}

<DEFAULT>
TOKEN :
{
 < ProcessingInstructionStart : "<?" > { pushState(DEFAULT); } : PROCESSING_INSTRUCTION
}

<ELEMENT_CONTENT>
TOKEN :
{
 < ProcessingInstructionStartForElementContent : "<?" > { pushState(); } : PROCESSING_INSTRUCTION
}

<PROCESSING_INSTRUCTION, PROCESSING_INSTRUCTION_CONTENT>
TOKEN :
{
 < ProcessingInstructionEnd : "?>" > { popState(); }
}

<PROCESSING_INSTRUCTION_CONTENT>
TOKEN :
{
 < PIContentChar : ["\t", "\r", "\n", " " - "\ufffd"] > : PROCESSING_INSTRUCTION_CONTENT
}

<CDATA_SECTION>
TOKEN :
{
 < CDataSectionChar : ["\t", "\r", "\n", " " - "\ufffd"] > : CDATA_SECTION
}

<DEFAULT>
TOKEN :
{
 < CdataSectionStart : "<![CDATA[" > { pushState(DEFAULT); } : CDATA_SECTION
}

<ELEMENT_CONTENT>
TOKEN :
{
 < CdataSectionStartForElementContent : "<![CDATA[" > { pushState(); } : CDATA_SECTION
}

<CDATA_SECTION>
TOKEN :
{
 < CdataSectionEnd : ("]" "]" ">") > { popState(); }
}

<DEFAULT>
TOKEN :
{
 < XmlCommentStart : "<!--" > { pushState(DEFAULT); } : XML_COMMENT
}

<ELEMENT_CONTENT>
TOKEN :
{
 < XmlCommentStartForElementContent : "<!--" > { pushState(); } : XML_COMMENT
}

<XML_COMMENT>
TOKEN :
{
 < XmlCommentEnd : "-->" > { popState(); }
}

SPECIAL_TOKEN :
{
 < #Comment : <CommentStart> ((<CommentContents>))* <CommentEnd> >
}

<DEFAULT, EXPR_COMMENT>
SPECIAL_TOKEN :
{
 < CommentStart : "(:" > { pushState(); } : EXPR_COMMENT
}

<EXPR_COMMENT>
SPECIAL_TOKEN :
{
 < CommentContent : <Char> >
}

<EXPR_COMMENT>
SPECIAL_TOKEN :
{
 < CommentEnd : ":)" > { popState(); }
}

<DEFAULT>
TOKEN :
{
 < Slash : "/" >
}

<DEFAULT>
TOKEN :
{
 < SlashSlash : "//" >
}

<PROCESSING_INSTRUCTION>
TOKEN :
{
 < PITargetError : ("xml" | "Xml" | "xMl" | "xmL" | "XMl" | "xML" | "xMl" | "XML" | "XmL") > : PROCESSING_INSTRUCTION
}

<PROCESSING_INSTRUCTION>
TOKEN :
{
 < PITarget : <NCNameTok> > : PROCESSING_INSTRUCTION
}

<DEFAULT, ELEMENT_CONTENT, QUOT_ATTRIBUTE_CONTENT, APOS_ATTRIBUTE_CONTENT>
TOKEN :
{
 < CharRef : "&#" (<Digits> |  (
"x" <HexDigits>)) ";" >
}

<DEFAULT>
TOKEN :
{
 < QNameToken : (<Prefix> ":")? <LocalPart> >
}

<PRAGMA>
TOKEN :
{
 < QNameForPragma : <QNameToken> > : PRAGMACONTENTSSPACEDIVIDER
}

<START_TAG>
TOKEN :
{
 < TagQName : <QNameToken> >
}

<END_TAG>
TOKEN :
{
 < EndTagQName : <QNameToken> >
}

TOKEN :
{
 < #NCNameTok : <Nmstart> (<Nmchar>)* >
}

<DEFAULT>
TOKEN :
{
 < NCNameColonStar : <NCNameTok> ":" "*" >
}

<DEFAULT>
TOKEN :
{
 < StarColonNCName : "*" ":" <NCNameTok> >
}

<DEFAULT, START_TAG, END_TAG>
TOKEN :
{
 < S : (<WhitespaceChar>)+  >
}

<PRAGMACONTENTSSPACEDIVIDER>
TOKEN :
{
 < SForPragma : (<WhitespaceChar>)+  > : PRAGMACONTENTS
}

<PROCESSING_INSTRUCTION>
TOKEN :
{
 < SForPI : (<WhitespaceChar>)+  > : PROCESSING_INSTRUCTION_CONTENT
}

<DEFAULT>
TOKEN :
{
 < Char : ["\t", "\r", "\n", " " - "\ufffd"] >
}

TOKEN :
{
 < #Digits : (["0" - "9"])+  >
}

SPECIAL_TOKEN :
{
 < #CommentContents : (<CommentContent>)+  >
}

TOKEN :
{
 < #WhitespaceChar : ["\t", "\r", "\n", " "] >
}

TOKEN :
{
 < #Letter : (<BaseChar> | <Ideographic>) >
}

TOKEN :
{
 < #BaseChar : ["A" - "Z", "a" - "z", "\u00c0" - "\u00d6", "\u00d8" - "\u00f6", "\u00f8" - "\u00ff", "\u0100" - "\u0131", "\u0134" - "\u013e", "\u0141" - "\u0148", "\u014a" - "\u017e", "\u0180" - "\u01c3", "\u01cd" - "\u01f0", "\u01f4" - "\u01f5", "\u01fa" - "\u0217", "\u0250" - "\u02a8", "\u02bb" - "\u02c1", "\u0386", "\u0388" - "\u038a", "\u038c", "\u038e" - "\u03a1", "\u03a3" - "\u03ce", "\u03d0" - "\u03d6", "\u03da", "\u03dc", "\u03de", "\u03e0", "\u03e2" - "\u03f3", "\u0401" - "\u040c", "\u040e" - "\u044f", "\u0451" - "\u045c", "\u045e" - "\u0481", "\u0490" - "\u04c4", "\u04c7" - "\u04c8", "\u04cb" - "\u04cc", "\u04d0" - "\u04eb", "\u04ee" - "\u04f5", "\u04f8" - "\u04f9", "\u0531" - "\u0556", "\u0559", "\u0561" - "\u0586", "\u05d0" - "\u05ea", "\u05f0" - "\u05f2", "\u0621" - "\u063a", "\u0641" - "\u064a", "\u0671" - "\u06b7", "\u06ba" - "\u06be", "\u06c0" - "\u06ce", "\u06d0" - "\u06d3", "\u06d5", "\u06e5" - "\u06e6", "\u0905" - "\u0939", "\u093d", "\u0958" - "\u0961", "\u0985" - "\u098c", "\u098f" - "\u0990", "\u0993" - "\u09a8", "\u09aa" - "\u09b0", "\u09b2", "\u09b6" - "\u09b9", "\u09dc" - "\u09dd", "\u09df" - "\u09e1", "\u09f0" - "\u09f1", "\u0a05" - "\u0a0a", "\u0a0f" - "\u0a10", "\u0a13" - "\u0a28", "\u0a2a" - "\u0a30", "\u0a32" - "\u0a33", "\u0a35" - "\u0a36", "\u0a38" - "\u0a39", "\u0a59" - "\u0a5c", "\u0a5e", "\u0a72" - "\u0a74", "\u0a85" - "\u0a8b", "\u0a8d", "\u0a8f" - "\u0a91", "\u0a93" - "\u0aa8", "\u0aaa" - "\u0ab0", "\u0ab2" - "\u0ab3", "\u0ab5" - "\u0ab9", "\u0abd", "\u0ae0", "\u0b05" - "\u0b0c", "\u0b0f" - "\u0b10", "\u0b13" - "\u0b28", "\u0b2a" - "\u0b30", "\u0b32" - "\u0b33", "\u0b36" - "\u0b39", "\u0b3d", "\u0b5c" - "\u0b5d", "\u0b5f" - "\u0b61", "\u0b85" - "\u0b8a", "\u0b8e" - "\u0b90", "\u0b92" - "\u0b95", "\u0b99" - "\u0b9a", "\u0b9c", "\u0b9e" - "\u0b9f", "\u0ba3" - "\u0ba4", "\u0ba8" - "\u0baa", "\u0bae" - "\u0bb5", "\u0bb7" - "\u0bb9", "\u0c05" - "\u0c0c", "\u0c0e" - "\u0c10", "\u0c12" - "\u0c28", "\u0c2a" - "\u0c33", "\u0c35" - "\u0c39", "\u0c60" - "\u0c61", "\u0c85" - "\u0c8c", "\u0c8e" - "\u0c90", "\u0c92" - "\u0ca8", "\u0caa" - "\u0cb3", "\u0cb5" - "\u0cb9", "\u0cde", "\u0ce0" - "\u0ce1", "\u0d05" - "\u0d0c", "\u0d0e" - "\u0d10", "\u0d12" - "\u0d28", "\u0d2a" - "\u0d39", "\u0d60" - "\u0d61", "\u0e01" - "\u0e2e", "\u0e30", "\u0e32" - "\u0e33", "\u0e40" - "\u0e45", "\u0e81" - "\u0e82", "\u0e84", "\u0e87" - "\u0e88", "\u0e8a", "\u0e8d", "\u0e94" - "\u0e97", "\u0e99" - "\u0e9f", "\u0ea1" - "\u0ea3", "\u0ea5", "\u0ea7", "\u0eaa" - "\u0eab", "\u0ead" - "\u0eae", "\u0eb0", "\u0eb2" - "\u0eb3", "\u0ebd", "\u0ec0" - "\u0ec4", "\u0f40" - "\u0f47", "\u0f49" - "\u0f69", "\u10a0" - "\u10c5", "\u10d0" - "\u10f6", "\u1100", "\u1102" - "\u1103", "\u1105" - "\u1107", "\u1109", "\u110b" - "\u110c", "\u110e" - "\u1112", "\u113c", "\u113e", "\u1140", "\u114c", "\u114e", "\u1150", "\u1154" - "\u1155", "\u1159", "\u115f" - "\u1161", "\u1163", "\u1165", "\u1167", "\u1169", "\u116d" - "\u116e", "\u1172" - "\u1173", "\u1175", "\u119e", "\u11a8", "\u11ab", "\u11ae" - "\u11af", "\u11b7" - "\u11b8", "\u11ba", "\u11bc" - "\u11c2", "\u11eb", "\u11f0", "\u11f9", "\u1e00" - "\u1e9b", "\u1ea0" - "\u1ef9", "\u1f00" - "\u1f15", "\u1f18" - "\u1f1d", "\u1f20" - "\u1f45", "\u1f48" - "\u1f4d", "\u1f50" - "\u1f57", "\u1f59", "\u1f5b", "\u1f5d", "\u1f5f" - "\u1f7d", "\u1f80" - "\u1fb4", "\u1fb6" - "\u1fbc", "\u1fbe", "\u1fc2" - "\u1fc4", "\u1fc6" - "\u1fcc", "\u1fd0" - "\u1fd3", "\u1fd6" - "\u1fdb", "\u1fe0" - "\u1fec", "\u1ff2" - "\u1ff4", "\u1ff6" - "\u1ffc", "\u2126", "\u212a" - "\u212b", "\u212e", "\u2180" - "\u2182", "\u3041" - "\u3094", "\u30a1" - "\u30fa", "\u3105" - "\u312c", "\uac00" - "\ud7a3"] >
}

TOKEN :
{
 < #Ideographic : ["\u4e00" - "\u9fa5", "\u3007", "\u3021" - "\u3029"] >
}

TOKEN :
{
 < #CombiningChar : ["\u0300" - "\u0345", "\u0360" - "\u0361", "\u0483" - "\u0486", "\u0591" - "\u05a1", "\u05a3" - "\u05b9", "\u05bb" - "\u05bd", "\u05bf", "\u05c1" - "\u05c2", "\u05c4", "\u064b" - "\u0652", "\u0670", "\u06d6" - "\u06dc", "\u06dd" - "\u06df", "\u06e0" - "\u06e4", "\u06e7" - "\u06e8", "\u06ea" - "\u06ed", "\u0901" - "\u0903", "\u093c", "\u093e" - "\u094c", "\u094d", "\u0951" - "\u0954", "\u0962" - "\u0963", "\u0981" - "\u0983", "\u09bc", "\u09be", "\u09bf", "\u09c0" - "\u09c4", "\u09c7" - "\u09c8", "\u09cb" - "\u09cd", "\u09d7", "\u09e2" - "\u09e3", "\u0a02", "\u0a3c", "\u0a3e", "\u0a3f", "\u0a40" - "\u0a42", "\u0a47" - "\u0a48", "\u0a4b" - "\u0a4d", "\u0a70" - "\u0a71", "\u0a81" - "\u0a83", "\u0abc", "\u0abe" - "\u0ac5", "\u0ac7" - "\u0ac9", "\u0acb" - "\u0acd", "\u0b01" - "\u0b03", "\u0b3c", "\u0b3e" - "\u0b43", "\u0b47" - "\u0b48", "\u0b4b" - "\u0b4d", "\u0b56" - "\u0b57", "\u0b82" - "\u0b83", "\u0bbe" - "\u0bc2", "\u0bc6" - "\u0bc8", "\u0bca" - "\u0bcd", "\u0bd7", "\u0c01" - "\u0c03", "\u0c3e" - "\u0c44", "\u0c46" - "\u0c48", "\u0c4a" - "\u0c4d", "\u0c55" - "\u0c56", "\u0c82" - "\u0c83", "\u0cbe" - "\u0cc4", "\u0cc6" - "\u0cc8", "\u0cca" - "\u0ccd", "\u0cd5" - "\u0cd6", "\u0d02" - "\u0d03", "\u0d3e" - "\u0d43", "\u0d46" - "\u0d48", "\u0d4a" - "\u0d4d", "\u0d57", "\u0e31", "\u0e34" - "\u0e3a", "\u0e47" - "\u0e4e", "\u0eb1", "\u0eb4" - "\u0eb9", "\u0ebb" - "\u0ebc", "\u0ec8" - "\u0ecd", "\u0f18" - "\u0f19", "\u0f35", "\u0f37", "\u0f39", "\u0f3e", "\u0f3f", "\u0f71" - "\u0f84", "\u0f86" - "\u0f8b", "\u0f90" - "\u0f95", "\u0f97", "\u0f99" - "\u0fad", "\u0fb1" - "\u0fb7", "\u0fb9", "\u20d0" - "\u20dc", "\u20e1", "\u302a" - "\u302f", "\u3099", "\u309a"] >
}

TOKEN :
{
 < #Digit : ["0" - "9", "\u0660" - "\u0669", "\u06f0" - "\u06f9", "\u0966" - "\u096f", "\u09e6" - "\u09ef", "\u0a66" - "\u0a6f", "\u0ae6" - "\u0aef", "\u0b66" - "\u0b6f", "\u0be7" - "\u0bef", "\u0c66" - "\u0c6f", "\u0ce6" - "\u0cef", "\u0d66" - "\u0d6f", "\u0e50" - "\u0e59", "\u0ed0" - "\u0ed9", "\u0f20" - "\u0f29"] >
}

TOKEN :
{
 < #Extender : ["\u00b7", "\u02d0", "\u02d1", "\u0387", "\u0640", "\u0e46", "\u0ec6", "\u3005", "\u3031" - "\u3035", "\u309d" - "\u309e", "\u30fc" - "\u30fe"] >
}

<DEFAULT>
TOKEN :
{
 < NotNumber : ( (
"." <Digits>) |  (
<Digits> ("." (["0" - "9"])*)?)) (["e", "E"] (["+", "-"])? <Digits>)? ["a" - "z", "A" - "Z"] (["0" - "9", "a" - "z", "A" - "Z"])* >
}
